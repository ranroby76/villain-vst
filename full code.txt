================================================================================
CODE DOCUMENTATION
Complete Source Code Archive
================================================================================

Generated: January 24, 2026
Total Files: 8
Generated by: Code PDF Builder

================================================================================
PROJECT STRUCTURE
================================================================================

Project Root/
├── CMakeLists.txt
├── .github/
│   └── workflows/
│       ├── build_au.yml
│       ├── build_mac.yml
│       └── build_windows.yml
└── src/
    ├── PluginEditor.cpp
    ├── PluginEditor.h
    ├── PluginProcessor.cpp
    └── PluginProcessor.h


================================================================================
FILE DETAILS
================================================================================

1. .github/workflows/build_au.yml
   Size: 3.89 KB
   Type: text/plain

2. .github/workflows/build_mac.yml
   Size: 5.73 KB
   Type: text/plain

3. .github/workflows/build_windows.yml
   Size: 1.97 KB
   Type: text/plain

4. src/PluginEditor.cpp
   Size: 17.21 KB
   Type: text/plain

5. src/PluginEditor.h
   Size: 8.95 KB
   Type: text/plain

6. src/PluginProcessor.cpp
   Size: 29.27 KB
   Type: text/plain

7. src/PluginProcessor.h
   Size: 3.02 KB
   Type: text/plain

8. CMakeLists.txt
   Size: 4.13 KB
   Type: text/plain


================================================================================
SOURCE CODE FILES
================================================================================

--------------------------------------------------------------------------------
File: .github/workflows/build_au.yml
Size: 3.89 KB
--------------------------------------------------------------------------------

name: Build macOS (AU Only)

on:
  workflow_dispatch:

jobs:
  build_au:
    name: Build AU
    runs-on: macos-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Install Dependencies
        run: |
          brew install ninja
          brew install cmake || brew upgrade cmake

      - name: Import Signing Certificate
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE }}
          P12_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: "admin"
        run: |
          echo $BUILD_CERTIFICATE_BASE64 | base64 --decode > certificate.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security import certificate.p12 -k build.keychain -P "$P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign
          security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain

      - name: Clone JUCE Framework
        run: |
          git clone --depth 1 --branch 8.0.4 https://github.com/juce-framework/JUCE.git libs/JUCE

      - name: Configure CMake
        run: |
          cmake -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_OSX_ARCHITECTURES="x86_64;arm64" \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=10.13 \
            -DJUCE_DIR=libs/JUCE \
            -DVILLAIN_ENABLE_VST3=OFF \
            -DVILLAIN_ENABLE_CLAP=OFF \
            -DVILLAIN_ENABLE_AU=ON

      - name: Build AU
        run: cmake --build build --config Release --parallel 4

      - name: Create Notarization Script
        run: |
          cat > notarize_au.sh << 'EOF'
          #!/bin/bash
          set -e
          
          security unlock-keychain -p "admin" build.keychain
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | head -1 | grep '"' | sed 's/^.*"\(.*\)".*$/\1/')
          
          if [ -d "build/Villain_artefacts/Release/AU/Villain.component" ]; then
            echo "Processing AU..."
            
            # Sign Bundle
            codesign --force --deep --options runtime --sign "$IDENTITY" "build/Villain_artefacts/Release/AU/Villain.component"
            
            # Verify
            codesign --verify --deep --strict --verbose=2 "build/Villain_artefacts/Release/AU/Villain.component"
            
            # Zip
            /usr/bin/ditto -c -k --keepParent "build/Villain_artefacts/Release/AU/Villain.component" "Villain_AU.zip"
            
            # Notarize
            xcrun notarytool submit "Villain_AU.zip" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$TEAM_ID" \
              --wait
            
            # Staple
            xcrun stapler staple "build/Villain_artefacts/Release/AU/Villain.component" || echo "Stapling failed (non-critical)"
          else
            echo "::error::AU Component not found!"
            exit 1
          fi
          EOF
          chmod +x notarize_au.sh

      - name: Sign & Notarize AU with Retry
        uses: nick-fields/retry@v3
        env:
          APPLE_ID: ${{ secrets.MACOS_NOTARIZATION_USERNAME }}
          APPLE_PASSWORD: ${{ secrets.MACOS_NOTARIZATION_PASSWORD }}
          TEAM_ID: ${{ secrets.MACOS_NOTARIZATION_TEAM_ID }}
        with:
          timeout_minutes: 30
          max_attempts: 3
          retry_wait_seconds: 60
          command: ./notarize_au.sh

      - name: Upload AU Artifact
        uses: actions/upload-artifact@v4
        with:
          name: Villain-Mac-AU-Signed
          path: build/Villain_artefacts/Release/AU/Villain.component




--------------------------------------------------------------------------------
File: .github/workflows/build_mac.yml
Size: 5.73 KB
--------------------------------------------------------------------------------

name: Build macOS (VST3/CLAP)

on:
  workflow_dispatch:

jobs:
  build_mac:
    name: Build macOS
    runs-on: macos-latest
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Install Dependencies
        run: |
          brew install ninja
          brew install cmake || brew upgrade cmake

      - name: Import Signing Certificate
        env:
          BUILD_CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE }}
          P12_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: "admin"
        run: |
          echo $BUILD_CERTIFICATE_BASE64 | base64 --decode > certificate.p12
          security create-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain
          security set-keychain-settings -lut 21600 build.keychain
          security import certificate.p12 -k build.keychain -P "$P12_PASSWORD" -T /usr/bin/codesign -T /usr/bin/productsign
          security set-key-partition-list -S apple-tool:,apple:,codesign:,productsign: -s -k "$KEYCHAIN_PASSWORD" build.keychain
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" build.keychain

      - name: Clone JUCE Framework
        run: |
          git clone --depth 1 --branch 8.0.4 https://github.com/juce-framework/JUCE.git libs/JUCE

      - name: Setup CLAP Extensions
        run: |
          git clone --recursive https://github.com/free-audio/clap-juce-extensions.git libs/CLAP_Extensions

      - name: Configure CMake
        run: |
          cmake -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=Release \
            -DCMAKE_OSX_ARCHITECTURES="x86_64;arm64" \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=10.13 \
            -DJUCE_DIR=libs/JUCE \
            -DCLAP_EXTENSIONS_DIR=libs/CLAP_Extensions \
            -DVILLAIN_ENABLE_VST3=ON \
            -DVILLAIN_ENABLE_CLAP=ON \
            -DVILLAIN_ENABLE_AU=OFF

      - name: Build All
        run: cmake --build build --config Release --parallel 4

      - name: Create Notarization Script
        run: |
          cat > notarize_mac.sh << 'EOF'
          #!/bin/bash
          set -e
          
          security unlock-keychain -p "admin" build.keychain
          
          echo "Starting Code Signing..."
          IDENTITY=$(security find-identity -v -p codesigning build.keychain | head -1 | grep '"' | sed 's/^.*"\(.*\)".*$/\1/')
          echo "Signing with identity: $IDENTITY"
          
          # --- VST3 ---
          if [ -d "build/Villain_artefacts/Release/VST3/Villain.vst3" ]; then
            echo "Processing VST3..."
            
            echo "Signing VST3 Bundle..."
            codesign --force --deep --options runtime --sign "$IDENTITY" "build/Villain_artefacts/Release/VST3/Villain.vst3"
            
            echo "Verifying VST3..."
            codesign --verify --deep --strict --verbose=2 "build/Villain_artefacts/Release/VST3/Villain.vst3"
            
            echo "Creating VST3 Zip..."
            /usr/bin/ditto -c -k --keepParent "build/Villain_artefacts/Release/VST3/Villain.vst3" "Villain_VST3.zip"
            
            echo "Submitting VST3 for notarization..."
            xcrun notarytool submit "Villain_VST3.zip" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$TEAM_ID" \
              --wait
            
            echo "Stapling VST3..."
            xcrun stapler staple "build/Villain_artefacts/Release/VST3/Villain.vst3" || echo "Stapling failed (non-critical)"
          fi
          
          # --- CLAP ---
          if [ -d "build/Villain_artefacts/Release/CLAP/Villain.clap" ]; then
            echo "Processing CLAP..."
            
            echo "Signing CLAP Bundle..."
            codesign --force --deep --options runtime --sign "$IDENTITY" "build/Villain_artefacts/Release/CLAP/Villain.clap"
            
            echo "Verifying CLAP..."
            codesign --verify --deep --strict --verbose=2 "build/Villain_artefacts/Release/CLAP/Villain.clap"
            
            echo "Creating CLAP Zip..."
            /usr/bin/ditto -c -k --keepParent "build/Villain_artefacts/Release/CLAP/Villain.clap" "Villain_CLAP.zip"
            
            echo "Submitting CLAP for notarization..."
            xcrun notarytool submit "Villain_CLAP.zip" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_PASSWORD" \
              --team-id "$TEAM_ID" \
              --wait
            
            echo "Stapling CLAP..."
            xcrun stapler staple "build/Villain_artefacts/Release/CLAP/Villain.clap" || echo "Stapling failed (non-critical)"
          fi
          EOF
          chmod +x notarize_mac.sh

      - name: Sign & Notarize with Retry
        uses: nick-fields/retry@v3
        env:
          APPLE_ID: ${{ secrets.MACOS_NOTARIZATION_USERNAME }}
          APPLE_PASSWORD: ${{ secrets.MACOS_NOTARIZATION_PASSWORD }}
          TEAM_ID: ${{ secrets.MACOS_NOTARIZATION_TEAM_ID }}
        with:
          timeout_minutes: 30
          max_attempts: 3
          retry_wait_seconds: 60
          command: ./notarize_mac.sh

      - name: Collect Artifacts
        run: |
          mkdir -p artifacts_mac
          if [ -d "build/Villain_artefacts/Release/VST3/Villain.vst3" ]; then
            cp -R "build/Villain_artefacts/Release/VST3/Villain.vst3" artifacts_mac/
          fi
          if [ -d "build/Villain_artefacts/Release/CLAP/Villain.clap" ]; then
            cp -R "build/Villain_artefacts/Release/CLAP/Villain.clap" artifacts_mac/
          fi

      - name: Upload Mac Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Villain-Mac-Universal-Signed
          path: artifacts_mac/




--------------------------------------------------------------------------------
File: .github/workflows/build_windows.yml
Size: 1.97 KB
--------------------------------------------------------------------------------

name: Build Windows (VST3 + CLAP)

on:
  push:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build_windows:
    name: Build Windows VST3 + CLAP
    runs-on: windows-2022
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Setup MSVC
        uses: ilammy/msvc-dev-cmd@v1

      - name: Install Ninja
        run: choco install ninja

      - name: Clone JUCE Framework
        run: |
          git clone --depth 1 --branch 8.0.4 https://github.com/juce-framework/JUCE.git libs/JUCE

      - name: Setup CLAP Extensions
        run: |
          git clone --recursive https://github.com/free-audio/clap-juce-extensions.git libs/CLAP_Extensions

      - name: Configure CMake
        run: |
          cmake -S . -B build -G "Ninja" `
            -DCMAKE_BUILD_TYPE=Release `
            -DJUCE_DIR=libs/JUCE `
            -DCLAP_EXTENSIONS_DIR=libs/CLAP_Extensions `
            -DVILLAIN_ENABLE_VST3=ON `
            -DVILLAIN_ENABLE_CLAP=ON `
            -DVILLAIN_ENABLE_AU=OFF

      - name: Build All
        run: cmake --build build --config Release --parallel 4

      - name: Collect Artifacts
        shell: bash
        run: |
          mkdir -p artifacts_win/VST3
          mkdir -p artifacts_win/CLAP
          
          if [ -d "build/Villain_artefacts/Release/VST3" ]; then
            cp -R build/Villain_artefacts/Release/VST3/* artifacts_win/VST3/
            echo "VST3 Found."
          else
            echo "::error::VST3 NOT FOUND"
            exit 1
          fi
          
          if [ -d "build/Villain_artefacts/Release/CLAP" ]; then
            cp -R build/Villain_artefacts/Release/CLAP/* artifacts_win/CLAP/
            echo "CLAP Found."
          else
            echo "::error::CLAP NOT FOUND"
            exit 1
          fi

      - name: Upload Windows Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: Villain-Windows-VST3-CLAP
          path: artifacts_win/




--------------------------------------------------------------------------------
File: src/PluginEditor.cpp
Size: 17.21 KB
--------------------------------------------------------------------------------

#include "PluginEditor.h"
#include "BinaryData.h"

static juce::Image loadPngFromBinary (const void* data, int size)
{
    return juce::ImageCache::getFromMemory (data, size);
}

static juce::Font makeComicLikeFont()
{
    return juce::Font (juce::FontOptions (juce::Font::getDefaultSansSerifFontName(), 16.0f, juce::Font::bold));
}

static juce::String stripNumericPrefix (juce::String s)
{
    // Remove leading numbering like: "1 ", "01 ", "1. ", "1) ", "01 - ", "1: " etc.
    s = s.trimStart();

    int i = 0;
    while (i < s.length() && juce::CharacterFunctions::isDigit (s[i]))
        ++i;

    if (i > 0)
    {
        while (i < s.length())
        {
            const juce::juce_wchar c = s[i];
            if (c == ' ' || c == '.' || c == ')' || c == '(' || c == '-' || c == ':' || c == 0x2013 || c == 0x2014)
                ++i;
            else
                break;
        }

        s = s.substring (i).trimStart();
    }

    return s;
}

static juce::String wordOnWordIfTwoWords (const juce::String& s)
{
    auto text = s.trim();

    // Split by whitespace.
    juce::StringArray parts;
    parts.addTokens (text, " \t\r\n", "");
    parts.removeEmptyStrings();

    if (parts.size() == 2)
        return parts[0] + "\n" + parts[1];

    return text;
}

static juce::String toTitleCaseWords (const juce::String& s)
{
    // Capital letter at start of each word (including words on separate lines).
    // Non-letters are preserved; we treat whitespace as word boundaries.
    juce::String out;
    out.preallocateBytes ((size_t) s.getNumBytesAsUTF8());

    bool atWordStart = true;

    for (int i = 0; i < s.length(); ++i)
    {
        const juce::juce_wchar c = s[i];

        if (juce::CharacterFunctions::isWhitespace (c))
        {
            out << c;
            atWordStart = true;
            continue;
        }

        if (juce::CharacterFunctions::isLetter (c))
        {
            if (atWordStart)
                out << juce::String::charToString (juce::CharacterFunctions::toUpperCase (c));
            else
                out << juce::String::charToString (juce::CharacterFunctions::toLowerCase (c));

            atWordStart = false;
            continue;
        }

        // Non-letter, non-whitespace: keep it, but don't force a new word unless next char is whitespace.
        out << c;
        atWordStart = false;
    }

    return out;
}

//==============================================================================
VillainAudioProcessorEditor::ModelGrid::ModelGrid (juce::AudioProcessorValueTreeState& state)
    : apvts (state)
{
    const auto names = VillainAudioProcessor::getModelNames();

    // Default: match UI text size. We will also update this on editor resize to keep scaling consistent.
    tableLnf.fixedFontHeight = 16.0f;

    for (int i = 0; i < VillainAudioProcessor::kNumModels; ++i)
    {
        auto& b = buttons[i];

        juce::String name = names[i];
        name = stripNumericPrefix (name);
        name = wordOnWordIfTwoWords (name);
        name = toTitleCaseWords (name);

        b.setButtonText (name);
        b.setClickingTogglesState (true);
        b.setRadioGroupId (0xBEEF);

        // Cell feel: avoid JUCE default bevels.
        b.setColour (juce::TextButton::buttonColourId,   juce::Colours::transparentBlack);
        b.setColour (juce::TextButton::buttonOnColourId, juce::Colours::transparentBlack);
        b.setColour (juce::TextButton::textColourOffId,  juce::Colours::black);
        b.setColour (juce::TextButton::textColourOnId,   juce::Colours::black);

        b.setConnectedEdges (juce::Button::ConnectedOnLeft
                           | juce::Button::ConnectedOnRight
                           | juce::Button::ConnectedOnTop
                           | juce::Button::ConnectedOnBottom);

        b.setLookAndFeel (&tableLnf);

        b.onClick = [this, i] { setModel (i); };
        addAndMakeVisible (b);
    }

    syncFromParameter();
    updateButtonStates();
}

VillainAudioProcessorEditor::ModelGrid::~ModelGrid()
{
    for (auto& b : buttons)
        b.setLookAndFeel (nullptr);
}

void VillainAudioProcessorEditor::ModelGrid::setSelectorFontHeight (float newHeight)
{
    tableLnf.fixedFontHeight = juce::jlimit (8.0f, 40.0f, newHeight);
    repaint();
}

void VillainAudioProcessorEditor::ModelGrid::paint (juce::Graphics& g)
{
    // Table border + grid lines (real "table" look)
    auto r = getLocalBounds();

    // Background behind cells
    g.setColour (juce::Colour::fromRGB (155, 125, 20));
    g.fillRoundedRectangle (r.toFloat(), 8.0f);

    // Grid
    const int cols = 5;
    const int rows = 2;

    const float x0 = (float) r.getX();
    const float y0 = (float) r.getY();
    const float w  = (float) r.getWidth();
    const float h  = (float) r.getHeight();

    const float cellW = w / (float) cols;
    const float cellH = h / (float) rows;

    // Border
    g.setColour (juce::Colours::black.withAlpha (0.55f));
    g.drawRoundedRectangle (r.toFloat().reduced (0.5f), 8.0f, 2.0f);

    // Inner lines
    g.setColour (juce::Colours::black.withAlpha (0.35f));

    for (int c = 1; c < cols; ++c)
    {
        const float x = x0 + cellW * (float) c;
        g.drawLine (x, y0, x, y0 + h, 1.0f);
    }

    for (int rr = 1; rr < rows; ++rr)
    {
        const float y = y0 + cellH * (float) rr;
        g.drawLine (x0, y, x0 + w, y, 1.0f);
    }
}

void VillainAudioProcessorEditor::ModelGrid::resized()
{
    auto r = getLocalBounds();

    const int cols = 5;
    const int rows = 2;

    const int cellW = r.getWidth() / cols;
    const int cellH = r.getHeight() / rows;

    int idx = 0;
    for (int row = 0; row < rows; ++row)
    {
        for (int col = 0; col < cols; ++col)
        {
            if (idx >= VillainAudioProcessor::kNumModels)
                break;

            auto cell = juce::Rectangle<int> (r.getX() + col * cellW,
                                              r.getY() + row * cellH,
                                              cellW,
                                              cellH);

            // 1px inset so grid lines remain visible.
            buttons[idx].setBounds (cell.reduced (1));
            ++idx;
        }
    }
}

void VillainAudioProcessorEditor::ModelGrid::setModel (int idx)
{
    idx = juce::jlimit (0, VillainAudioProcessor::kNumModels - 1, idx);

    if (auto* p = apvts.getParameter (VillainAudioProcessor::paramModelId))
    {
        const float normalized = p->convertTo0to1 ((float) idx);
        p->beginChangeGesture();
        p->setValueNotifyingHost (normalized);
        p->endChangeGesture();
    }
}

void VillainAudioProcessorEditor::ModelGrid::updateButtonStates()
{
    for (int i = 0; i < VillainAudioProcessor::kNumModels; ++i)
        buttons[i].setToggleState (i == selected, juce::dontSendNotification);
}

void VillainAudioProcessorEditor::ModelGrid::syncFromParameter()
{
    if (auto* v = apvts.getRawParameterValue (VillainAudioProcessor::paramModelId))
    {
        selected = juce::jlimit (0, VillainAudioProcessor::kNumModels - 1,
                                 (int) std::round (v->load()));
        updateButtonStates();
    }
}

//==============================================================================
VillainAudioProcessorEditor::PresetBar::PresetBar (VillainAudioProcessor& proc)
    : processor (proc),
      comicFont (makeComicLikeFont().withHeight (16.0f)),
      lnf (comicFont)
{
    presetBox.setEditableText (true);
    presetBox.setJustificationType (juce::Justification::centredLeft);
    presetBox.setTextWhenNothingSelected ("Default");
    presetBox.setTextWhenNoChoicesAvailable ("Default");
    presetBox.setText ("Default", juce::dontSendNotification);

    presetBox.setLookAndFeel (&lnf);
    loadButton.setLookAndFeel (&lnf);
    saveButton.setLookAndFeel (&lnf);

    loadButton.setColour (juce::TextButton::buttonColourId, juce::Colour::fromRGB (40, 40, 40));
    loadButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);

    saveButton.setColour (juce::TextButton::buttonColourId, juce::Colour::fromRGB (40, 40, 40));
    saveButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);

    loadButton.onClick = [this] { onLoad(); };
    saveButton.onClick = [this] { onSave(); };

    presetBox.onChange = [this]
    {
        processor.setCurrentPresetName (presetBox.getText());
    };

    addAndMakeVisible (presetBox);
    addAndMakeVisible (loadButton);
    addAndMakeVisible (saveButton);

    refreshPresetName();
}

VillainAudioProcessorEditor::PresetBar::~PresetBar()
{
    presetBox.setLookAndFeel (nullptr);
    loadButton.setLookAndFeel (nullptr);
    saveButton.setLookAndFeel (nullptr);
}

void VillainAudioProcessorEditor::PresetBar::paint (juce::Graphics& g)
{
    g.setColour (juce::Colour::fromRGB (25, 25, 25));
    g.fillRoundedRectangle (getLocalBounds().toFloat(), 10.0f);

    g.setColour (juce::Colours::black.withAlpha (0.35f));
    g.drawRoundedRectangle (getLocalBounds().toFloat().reduced (1.0f), 10.0f, 2.0f);
}

void VillainAudioProcessorEditor::PresetBar::resized()
{
    auto r = getLocalBounds().reduced (8);

    auto left = r.removeFromLeft (r.getWidth() - 160);
    presetBox.setBounds (left);

    auto btnArea = r;
    saveButton.setBounds (btnArea.removeFromRight (76).reduced (2));
    loadButton.setBounds (btnArea.removeFromRight (76).reduced (2));
}

void VillainAudioProcessorEditor::PresetBar::refreshPresetName()
{
    const auto name = processor.getCurrentPresetName();
    if (name.isNotEmpty() && presetBox.getText() != name)
        presetBox.setText (name, juce::dontSendNotification);
}

void VillainAudioProcessorEditor::PresetBar::onLoad()
{
    fileChooser = std::make_unique<juce::FileChooser> ("Load Villain preset...", juce::File(), "*.villainpreset");

    fileChooser->launchAsync (juce::FileBrowserComponent::openMode | juce::FileBrowserComponent::canSelectFiles,
                              [this] (const juce::FileChooser& fc)
                              {
                                  const auto file = fc.getResult();
                                  if (!file.existsAsFile())
                                      return;

                                  juce::String loadedName, err;
                                  if (!processor.loadPresetFromFile (file, loadedName, err))
                                  {
                                      juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon, "Villain", err);
                                      return;
                                  }

                                  processor.setCurrentPresetName (loadedName);
                                  presetBox.setText (loadedName, juce::dontSendNotification);
                              });
}

void VillainAudioProcessorEditor::PresetBar::onSave()
{
    fileChooser = std::make_unique<juce::FileChooser> ("Save Villain preset...", juce::File(), "*.villainpreset");

    fileChooser->launchAsync (juce::FileBrowserComponent::saveMode | juce::FileBrowserComponent::canSelectFiles,
                              [this] (const juce::FileChooser& fc)
                              {
                                  auto file = fc.getResult();
                                  if (file == juce::File())
                                      return;

                                  if (file.getFileExtension().isEmpty())
                                      file = file.withFileExtension (".villainpreset");

                                  const auto presetName = file.getFileNameWithoutExtension();

                                  juce::String err;
                                  if (!processor.savePresetToFile (file, presetName, err))
                                  {
                                      juce::AlertWindow::showMessageBoxAsync (juce::AlertWindow::WarningIcon, "Villain", err);
                                      return;
                                  }

                                  processor.setCurrentPresetName (presetName);
                                  presetBox.setText (presetName, juce::dontSendNotification);
                              });
}

//==============================================================================
VillainAudioProcessorEditor::VillainAudioProcessorEditor (VillainAudioProcessor& p)
    : AudioProcessorEditor (&p),
      processorRef (p),
      apvts (p.getAPVTS()),
      modelGrid (apvts),
      presetBar (p),
      resizer (this, &resizeConstrainer)
{
    // Default editor size: 75% of the original design size.
    const int startW = juce::roundToInt ((float) kUiW * 0.75f);
    const int startH = juce::roundToInt ((float) kUiH * 0.75f);

    resizeConstrainer.setFixedAspectRatio ((double) kUiW / (double) kUiH);

    const int minW = juce::roundToInt ((float) kUiW * 0.50f);
    const int minH = juce::roundToInt ((float) kUiH * 0.50f);
    const int maxW = juce::roundToInt ((float) kUiW * 2.00f);
    const int maxH = juce::roundToInt ((float) kUiH * 2.00f);
    resizeConstrainer.setSizeLimits (minW, minH, maxW, maxH);

    setResizable (true, true);
    setConstrainer (&resizeConstrainer);
    setSize (startW, startH);

    pages[0] = loadPngFromBinary (BinaryData::a1_png,  BinaryData::a1_pngSize);
    pages[1] = loadPngFromBinary (BinaryData::a2_png,  BinaryData::a2_pngSize);
    pages[2] = loadPngFromBinary (BinaryData::a3_png,  BinaryData::a3_pngSize);
    pages[3] = loadPngFromBinary (BinaryData::a4_png,  BinaryData::a4_pngSize);
    pages[4] = loadPngFromBinary (BinaryData::a5_png,  BinaryData::a5_pngSize);
    pages[5] = loadPngFromBinary (BinaryData::a6_png,  BinaryData::a6_pngSize);
    pages[6] = loadPngFromBinary (BinaryData::a7_png,  BinaryData::a7_pngSize);
    pages[7] = loadPngFromBinary (BinaryData::a8_png,  BinaryData::a8_pngSize);
    pages[8] = loadPngFromBinary (BinaryData::a9_png,  BinaryData::a9_pngSize);
    pages[9] = loadPngFromBinary (BinaryData::a10_png, BinaryData::a10_pngSize);

    // Updated knob filmstrip: 128 x 12928, 101 steps (vertical frames).
    knobFilmstrip = loadPngFromBinary (BinaryData::knob_png, BinaryData::knob_pngSize);
    knobLnf.setFilmstrip (knobFilmstrip, 101, true);

    mixKnob.setSliderStyle (juce::Slider::RotaryHorizontalVerticalDrag);
    mixKnob.setTextBoxStyle (juce::Slider::NoTextBox, false, 0, 0);
    mixKnob.setLookAndFeel (&knobLnf);

    // New max behavior: 70% is now the "effective 100%".
    // Meaning: the knob still goes 0..1, but we clamp the control range to 0..0.70.
    // So visual 100% equals 0.70 internally.
    mixKnob.setRange (0.0, 0.70, 0.007); // 101 steps: 0..0.70 in 1% chunks of the OLD range
    mixKnob.setDoubleClickReturnValue (true, 0.0);

    // Ensure normal cursor when not dragging.
    mixKnob.setMouseCursor (juce::MouseCursor::PointingHandCursor);

    addAndMakeVisible (mixKnob);
    mixAttachment = std::make_unique<juce::AudioProcessorValueTreeState::SliderAttachment> (
        apvts, VillainAudioProcessor::paramMixId, mixKnob);

    addAndMakeVisible (presetBar);
    addAndMakeVisible (modelGrid);

    addAndMakeVisible (resizer);
    resizer.setAlwaysOnTop (true);

    startTimerHz (30);
    timerCallback();
}

VillainAudioProcessorEditor::~VillainAudioProcessorEditor()
{
    mixKnob.setLookAndFeel (nullptr);
}

void VillainAudioProcessorEditor::timerCallback()
{
    const int model = juce::jlimit (0, VillainAudioProcessor::kNumModels - 1,
                                   (int) std::round (apvts.getRawParameterValue (VillainAudioProcessor::paramModelId)->load()));

    if (model != currentModel)
    {
        currentModel = model;
        repaint();
    }

    presetBar.refreshPresetName();
    modelGrid.syncFromParameter();
}

void VillainAudioProcessorEditor::paint (juce::Graphics& g)
{
    g.fillAll (juce::Colours::black);

    auto page = pages[currentModel];
    if (!page.isValid())
        return;

    const float s = (float) getWidth() / (float) kUiW;

    if (std::abs (s - 1.0f) < 1.0e-6f)
    {
        g.drawImageAt (page, 0, 0, false);
    }
    else
    {
        g.setImageResamplingQuality (juce::Graphics::highResamplingQuality);

        const auto t = juce::AffineTransform::scale (s);
        g.drawImageTransformed (page, t, false);
    }
}

void VillainAudioProcessorEditor::resized()
{
    const float s = (float) getWidth() / (float) kUiW;

    // Keep selector text size consistent with the UI text and scale with the UI.
    modelGrid.setSelectorFontHeight (16.0f * s);

    auto scaleRect = [s] (juce::Rectangle<int> r)
    {
        return juce::Rectangle<int> (juce::roundToInt ((float) r.getX() * s),
                                     juce::roundToInt ((float) r.getY() * s),
                                     juce::roundToInt ((float) r.getWidth() * s),
                                     juce::roundToInt ((float) r.getHeight() * s));
    };

    auto scaleRectF = [s] (juce::Rectangle<float> r)
    {
        return juce::Rectangle<int> (juce::roundToInt (r.getX() * s),
                                     juce::roundToInt (r.getY() * s),
                                     juce::roundToInt (r.getWidth() * s),
                                     juce::roundToInt (r.getHeight() * s));
    };

    presetBar.setBounds (scaleRect (presetBounds));
    modelGrid.setBounds (scaleRect (selectorBounds));
    mixKnob.setBounds   (scaleRectF (mixKnobBoundsF));

    const int grip = juce::roundToInt (16.0f * s);
    resizer.setBounds (getWidth() - grip, getHeight() - grip, grip, grip);
}




--------------------------------------------------------------------------------
File: src/PluginEditor.h
Size: 8.95 KB
--------------------------------------------------------------------------------

#pragma once

#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_gui_basics/juce_gui_basics.h>
#include <juce_gui_extra/juce_gui_extra.h>

#include "PluginProcessor.h"

class VillainAudioProcessorEditor final : public juce::AudioProcessorEditor,
                                          private juce::Timer
{
public:
    explicit VillainAudioProcessorEditor (VillainAudioProcessor&);
    ~VillainAudioProcessorEditor() override;

    void paint (juce::Graphics&) override;
    void resized() override;

private:
    void timerCallback() override;

    VillainAudioProcessor& processorRef;
    juce::AudioProcessorValueTreeState& apvts;

    juce::Image pages[VillainAudioProcessor::kNumModels];
    juce::Image knobFilmstrip;

    int currentModel = 0;

    //==============================================================================
    class FilmstripKnobLookAndFeel : public juce::LookAndFeel_V4
    {
    public:
        void setFilmstrip (juce::Image img, int frames, bool vertical)
        {
            filmstrip = img;
            numFrames = juce::jmax (1, frames);
            isVertical = vertical;
        }

        void drawRotarySlider (juce::Graphics& g, int x, int y, int w, int h,
                               float sliderPosProportional,
                               float /*rotaryStartAngle*/, float /*rotaryEndAngle*/,
                               juce::Slider& /*slider*/) override
        {
            if (!filmstrip.isValid() || numFrames <= 0)
                return;

            const int frame = juce::jlimit (0, numFrames - 1,
                                            (int) std::round (sliderPosProportional * (float) (numFrames - 1)));

            if (isVertical)
            {
                const int fw = filmstrip.getWidth();
                const int fh = filmstrip.getHeight() / numFrames;
                juce::Rectangle<int> src (0, frame * fh, fw, fh);
                g.drawImage (filmstrip, x, y, w, h, src.getX(), src.getY(), src.getWidth(), src.getHeight());
            }
            else
            {
                const int fw = filmstrip.getWidth() / numFrames;
                const int fh = filmstrip.getHeight();
                juce::Rectangle<int> src (frame * fw, 0, fw, fh);
                g.drawImage (filmstrip, x, y, w, h, src.getX(), src.getY(), src.getWidth(), src.getHeight());
            }
        }

    private:
        juce::Image filmstrip;
        int numFrames = 1;
        bool isVertical = true;
    };

    FilmstripKnobLookAndFeel knobLnf;

    //==============================================================================
    // Mix knob: keep cursor "frozen" (unbounded movement) while dragging + show different cursor icon.
    class MixKnobSlider final : public juce::Slider
    {
    public:
        MixKnobSlider() = default;

        void mouseDown (const juce::MouseEvent& e) override
        {
            // Hide/lock the OS pointer movement so it won't roam away from the knob.
            e.source.enableUnboundedMouseMovement (true);

            // Use a different cursor while dragging.
            setMouseCursor (juce::MouseCursor::DraggingHandCursor);

            juce::Slider::mouseDown (e);
        }

        void mouseUp (const juce::MouseEvent& e) override
        {
            juce::Slider::mouseUp (e);

            e.source.enableUnboundedMouseMovement (false);
            setMouseCursor (juce::MouseCursor::NormalCursor);
        }

        void mouseExit (const juce::MouseEvent& e) override
        {
            // Safety: if for any reason we leave while dragging, ensure we return cursor.
            if (! isMouseButtonDown())
                setMouseCursor (juce::MouseCursor::NormalCursor);

            juce::Slider::mouseExit (e);
        }
    };

    MixKnobSlider mixKnob;
    std::unique_ptr<juce::AudioProcessorValueTreeState::SliderAttachment> mixAttachment;

    //==============================================================================
    class ModelGrid : public juce::Component
    {
    public:
        explicit ModelGrid (juce::AudioProcessorValueTreeState& state);
        ~ModelGrid() override;

        void resized() override;
        void paint (juce::Graphics& g) override;

        void syncFromParameter();
        int  getSelected() const { return selected; }

        // Set selector font size (in pixels). We will match the UI text size (e.g. "the great electricity").
        void setSelectorFontHeight (float newHeight);

    private:
        juce::AudioProcessorValueTreeState& apvts;

        struct TableButtonLookAndFeel : public juce::LookAndFeel_V4
        {
            float fixedFontHeight = 16.0f;

            juce::Font getTextButtonFont (juce::TextButton&, int /*buttonHeight*/) override
            {
                return juce::Font (juce::FontOptions (juce::Font::getDefaultSansSerifFontName(),
                                   juce::jmax (8.0f, fixedFontHeight),
                                   juce::Font::bold));
            }

            void drawButtonBackground (juce::Graphics& g,
                                       juce::Button& button,
                                       const juce::Colour& /*backgroundColour*/,
                                       bool isMouseOverButton,
                                       bool isButtonDown) override
            {
                const bool on = button.getToggleState();

                auto r = button.getLocalBounds().toFloat();

                auto baseOff  = juce::Colour::fromRGB (165, 135, 25);
                auto baseOn   = juce::Colour::fromRGB (220, 185, 40);
                auto hoverAdd = juce::Colour::fromFloatRGBA (1.0f, 1.0f, 1.0f, 0.07f);
                auto downAdd  = juce::Colour::fromFloatRGBA (0.0f, 0.0f, 0.0f, 0.08f);

                auto c = on ? baseOn : baseOff;

                if (isMouseOverButton)
                    c = c.overlaidWith (hoverAdd);

                if (isButtonDown)
                    c = c.overlaidWith (downAdd);

                g.setColour (c);
                g.fillRect (r);
            }

            void drawButtonText (juce::Graphics& g,
                                 juce::TextButton& button,
                                 bool /*isMouseOverButton*/,
                                 bool /*isButtonDown*/) override
            {
                juce::Font f = getTextButtonFont (button, button.getHeight());
                g.setFont (f);

                g.setColour (juce::Colours::black);

                auto r = button.getLocalBounds().reduced (4);

                // Allow 2 lines so "word on word" names can render fully.
                g.drawFittedText (button.getButtonText(), r, juce::Justification::centred, 2);
            }
        };

        TableButtonLookAndFeel tableLnf;

        juce::TextButton buttons[VillainAudioProcessor::kNumModels];
        int selected = 0;

        void setModel (int idx);
        void updateButtonStates();

        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (ModelGrid)
    };

    ModelGrid modelGrid;

    //==============================================================================
    class PresetBar : public juce::Component
    {
    public:
        explicit PresetBar (VillainAudioProcessor& proc);
        ~PresetBar() override;

        void resized() override;
        void paint (juce::Graphics& g) override;

        void refreshPresetName();

    private:
        VillainAudioProcessor& processor;

        struct PresetLookAndFeel : public juce::LookAndFeel_V4
        {
            juce::Font f;
            explicit PresetLookAndFeel (juce::Font font) : f (std::move (font)) {}

            juce::Font getComboBoxFont (juce::ComboBox&) override { return f; }
            juce::Font getTextButtonFont (juce::TextButton&, int) override { return f; }
        };

        juce::Font comicFont;
        PresetLookAndFeel lnf;

        juce::ComboBox presetBox;
        juce::TextButton loadButton { "Load" };
        juce::TextButton saveButton { "Save" };

        std::unique_ptr<juce::FileChooser> fileChooser;

        void onLoad();
        void onSave();

        JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (PresetBar)
    };

    PresetBar presetBar;

    //==============================================================================
    // Resizing support (corner drag + aspect-locked scaling)
    juce::ComponentBoundsConstrainer resizeConstrainer;
    juce::ResizableCornerComponent   resizer;

    //==============================================================================
    // Base UI geometry (designed for the background PNG pages)
    const juce::Rectangle<int> presetBounds   { 24, 127, 500, 52 };
    const juce::Rectangle<int> selectorBounds { 24, 187, 500, 110 };

    // Correct knob placement in base (100%) coordinates
    const juce::Rectangle<float> mixKnobBoundsF { 373.5f, 655.5f, 128.0f, 128.0f };

    static constexpr int kUiW = 550;
    static constexpr int kUiH = 844;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VillainAudioProcessorEditor)
};




--------------------------------------------------------------------------------
File: src/PluginProcessor.cpp
Size: 29.27 KB
--------------------------------------------------------------------------------

#include "PluginProcessor.h"
#include "PluginEditor.h"

//==============================================================================
// UTILITY FUNCTIONS
//==============================================================================
static inline float clampf (float v, float lo, float hi) { return (v < lo) ? lo : (v > hi) ? hi : v; }
static inline int   clampi (int v, int lo, int hi) { return (v < lo) ? lo : (v > hi) ? hi : v; }
static inline float lerpf  (float a, float b, float t) { return a + (b - a) * t; }

//==============================================================================
// CHEBYSHEV POLYNOMIALS - For targeted harmonic generation
// These generate specific harmonics when applied to a sine wave input
//==============================================================================
static inline float cheb2 (float x) { return 2.0f * x * x - 1.0f; }                           // 2nd harmonic
static inline float cheb3 (float x) { return x * (4.0f * x * x - 3.0f); }                     // 3rd harmonic
static inline float cheb4 (float x) { float x2 = x * x; return 8.0f * x2 * x2 - 8.0f * x2 + 1.0f; }  // 4th
static inline float cheb5 (float x) { float x2 = x * x; return x * (16.0f * x2 * x2 - 20.0f * x2 + 5.0f); } // 5th

//==============================================================================
// FAST APPROXIMATIONS
//==============================================================================
static inline float fastTanh (float x)
{
    // Pade approximation - accurate for |x| < 3, clamped beyond
    x = clampf (x, -4.5f, 4.5f);
    float x2 = x * x;
    return x * (27.0f + x2) / (27.0f + 9.0f * x2);
}

//==============================================================================
// HARMONIC WAVESHAPER
// Attempt mix of Chebyshev polynomials for targeted harmonic content
//==============================================================================
struct HarmonicShaper
{
    float h2 = 0.0f;  // 2nd harmonic amount (even - tube/warm)
    float h3 = 0.0f;  // 3rd harmonic amount (odd - transformer/crunch)
    float h4 = 0.0f;  // 4th harmonic
    float h5 = 0.0f;  // 5th harmonic
    float drive = 1.0f;
    float asymmetry = 0.0f;  // 0 = symmetric, >0 = more positive bias

    float process (float x) const
    {
        // Apply drive
        float driven = x * drive;

        // Soft clip the input to keep Chebyshev polynomials stable
        float clipped = clampf (driven, -1.0f, 1.0f);

        // Attempt fundamental + harmonics mix
        float fundamental = fastTanh (driven);

        // Add targeted harmonics (scaled by input level for natural behavior)
        float level = std::fabs (clipped);
        float harmonics = h2 * cheb2 (clipped) * level
                        + h3 * cheb3 (clipped) * level
                        + h4 * cheb4 (clipped) * level * 0.7f
                        + h5 * cheb5 (clipped) * level * 0.5f;

        float out = fundamental + harmonics;

        // Apply asymmetry (even harmonic boost from DC bias behavior)
        if (asymmetry > 0.0f)
        {
            float bias = asymmetry * 0.1f;
            out = fastTanh ((out + bias) * 1.1f) - fastTanh (bias);
        }

        return out;
    }
};

//==============================================================================
// FILTERS
//==============================================================================
struct OnePoleLP
{
    float z = 0.0f;
    float a = 0.0f;

    void setCutoff (float hz, float sr)
    {
        hz = clampf (hz, 10.0f, sr * 0.49f);
        a = std::exp (-6.28318530718f * hz / sr);
    }

    float process (float x)
    {
        z = a * z + (1.0f - a) * x;
        return z;
    }

    void reset() { z = 0.0f; }
};

struct OnePoleHP
{
    float z = 0.0f;
    float a = 0.0f;

    void setCutoff (float hz, float sr)
    {
        hz = clampf (hz, 10.0f, sr * 0.49f);
        a = std::exp (-6.28318530718f * hz / sr);
    }

    float process (float x)
    {
        z = a * z + (1.0f - a) * x;
        return x - z;
    }

    void reset() { z = 0.0f; }
};

//==============================================================================
// BIQUAD FILTER - For crossover and EQ
//==============================================================================
struct Biquad
{
    float b0 = 1.0f, b1 = 0.0f, b2 = 0.0f;
    float a1 = 0.0f, a2 = 0.0f;
    float z1 = 0.0f, z2 = 0.0f;

    void reset() { z1 = z2 = 0.0f; }

    float process (float x)
    {
        float y = b0 * x + b1 * z1 + b2 * z2 - a1 * z1 - a2 * z2;
        z2 = z1;
        z1 = y;
        return y;
    }

    void setLowpass (float freq, float q, float sr)
    {
        float w0 = 6.28318530718f * freq / sr;
        float cosw0 = std::cos (w0);
        float sinw0 = std::sin (w0);
        float alpha = sinw0 / (2.0f * q);

        float a0 = 1.0f + alpha;
        b0 = ((1.0f - cosw0) / 2.0f) / a0;
        b1 = (1.0f - cosw0) / a0;
        b2 = b0;
        a1 = (-2.0f * cosw0) / a0;
        a2 = (1.0f - alpha) / a0;
    }

    void setHighpass (float freq, float q, float sr)
    {
        float w0 = 6.28318530718f * freq / sr;
        float cosw0 = std::cos (w0);
        float sinw0 = std::sin (w0);
        float alpha = sinw0 / (2.0f * q);

        float a0 = 1.0f + alpha;
        b0 = ((1.0f + cosw0) / 2.0f) / a0;
        b1 = -(1.0f + cosw0) / a0;
        b2 = b0;
        a1 = (-2.0f * cosw0) / a0;
        a2 = (1.0f - alpha) / a0;
    }

    void setLowShelf (float freq, float gainDb, float sr)
    {
        float A = std::pow (10.0f, gainDb / 40.0f);
        float w0 = 6.28318530718f * freq / sr;
        float cosw0 = std::cos (w0);
        float sinw0 = std::sin (w0);
        float alpha = sinw0 / 2.0f * std::sqrt (2.0f);

        float a0 = (A + 1.0f) + (A - 1.0f) * cosw0 + 2.0f * std::sqrt (A) * alpha;
        b0 = (A * ((A + 1.0f) - (A - 1.0f) * cosw0 + 2.0f * std::sqrt (A) * alpha)) / a0;
        b1 = (2.0f * A * ((A - 1.0f) - (A + 1.0f) * cosw0)) / a0;
        b2 = (A * ((A + 1.0f) - (A - 1.0f) * cosw0 - 2.0f * std::sqrt (A) * alpha)) / a0;
        a1 = (-2.0f * ((A - 1.0f) + (A + 1.0f) * cosw0)) / a0;
        a2 = ((A + 1.0f) + (A - 1.0f) * cosw0 - 2.0f * std::sqrt (A) * alpha) / a0;
    }

    void setHighShelf (float freq, float gainDb, float sr)
    {
        float A = std::pow (10.0f, gainDb / 40.0f);
        float w0 = 6.28318530718f * freq / sr;
        float cosw0 = std::cos (w0);
        float sinw0 = std::sin (w0);
        float alpha = sinw0 / 2.0f * std::sqrt (2.0f);

        float a0 = (A + 1.0f) - (A - 1.0f) * cosw0 + 2.0f * std::sqrt (A) * alpha;
        b0 = (A * ((A + 1.0f) + (A - 1.0f) * cosw0 + 2.0f * std::sqrt (A) * alpha)) / a0;
        b1 = (-2.0f * A * ((A - 1.0f) + (A + 1.0f) * cosw0)) / a0;
        b2 = (A * ((A + 1.0f) + (A - 1.0f) * cosw0 - 2.0f * std::sqrt (A) * alpha)) / a0;
        a1 = (2.0f * ((A - 1.0f) - (A + 1.0f) * cosw0)) / a0;
        a2 = ((A + 1.0f) - (A - 1.0f) * cosw0 - 2.0f * std::sqrt (A) * alpha) / a0;
    }

    void setPeak (float freq, float gainDb, float q, float sr)
    {
        float A = std::pow (10.0f, gainDb / 40.0f);
        float w0 = 6.28318530718f * freq / sr;
        float cosw0 = std::cos (w0);
        float sinw0 = std::sin (w0);
        float alpha = sinw0 / (2.0f * q);

        float a0 = 1.0f + alpha / A;
        b0 = (1.0f + alpha * A) / a0;
        b1 = (-2.0f * cosw0) / a0;
        b2 = (1.0f - alpha * A) / a0;
        a1 = b1;
        a2 = (1.0f - alpha / A) / a0;
    }
};

//==============================================================================
// DC BLOCKER
//==============================================================================
struct DcBlocker
{
    float x1 = 0.0f, y1 = 0.0f;
    float r = 0.995f;

    void setFreq (float hz, float sr)
    {
        r = 1.0f - (6.28318530718f * hz / sr);
        r = clampf (r, 0.9f, 0.999f);
    }

    float process (float x)
    {
        float y = x - x1 + r * y1;
        x1 = x;
        y1 = y;
        return y;
    }

    void reset() { x1 = y1 = 0.0f; }
};

//==============================================================================
// ENVELOPE FOLLOWER - For transient/compression behavior
//==============================================================================
struct EnvelopeFollower
{
    float env = 0.0f;
    float attackCoef = 0.0f;
    float releaseCoef = 0.0f;

    void setTimes (float attackMs, float releaseMs, float sr)
    {
        attackCoef = 1.0f - std::exp (-1.0f / (attackMs * 0.001f * sr));
        releaseCoef = 1.0f - std::exp (-1.0f / (releaseMs * 0.001f * sr));
    }

    float process (float x)
    {
        float abs_x = std::fabs (x);
        if (abs_x > env)
            env += attackCoef * (abs_x - env);
        else
            env += releaseCoef * (abs_x - env);
        return env;
    }

    void reset() { env = 0.0f; }
};

//==============================================================================
// 3-BAND CROSSOVER - For multiband saturation
//==============================================================================
struct ThreeBandCrossover
{
    Biquad lp1, lp2;   // Low band
    Biquad hp1, hp2;   // High band
    // Mid = input - low - high (allpass derived)

    float lowFreq = 200.0f;
    float highFreq = 3000.0f;

    void setup (float lowF, float highF, float sr)
    {
        lowFreq = lowF;
        highFreq = highF;

        lp1.setLowpass (lowF, 0.707f, sr);
        lp2.setLowpass (lowF, 0.707f, sr);
        hp1.setHighpass (highF, 0.707f, sr);
        hp2.setHighpass (highF, 0.707f, sr);
    }

    void process (float x, float& low, float& mid, float& high)
    {
        low = lp2.process (lp1.process (x));
        high = hp2.process (hp1.process (x));
        mid = x - low - high;
    }

    void reset()
    {
        lp1.reset(); lp2.reset();
        hp1.reset(); hp2.reset();
    }
};

//==============================================================================
// TRANSFORMER EMULATION
// Models frequency-dependent saturation and subtle phase behavior
//==============================================================================
struct TransformerStage
{
    Biquad lowBoost;
    Biquad highRoll;
    HarmonicShaper shaper;
    EnvelopeFollower envLow;
    float bassWeight = 1.0f;
    float sr = 44100.0f;

    void setup (float sampleRate, float bassW, float h2, float h3, float drive)
    {
        sr = sampleRate;
        bassWeight = bassW;
        shaper.h2 = h2;
        shaper.h3 = h3;
        shaper.drive = drive;

        lowBoost.setLowShelf (120.0f, bassW * 2.0f, sr);
        highRoll.setLowpass (18000.0f, 0.707f, sr);
        envLow.setTimes (5.0f, 80.0f, sr);
    }

    float process (float x)
    {
        // Bass frequencies saturate first (transformer core behavior)
        float env = envLow.process (x);
        float dynamicDrive = shaper.drive * (1.0f + env * bassWeight * 0.3f);

        HarmonicShaper dynShaper = shaper;
        dynShaper.drive = dynamicDrive;

        float shaped = dynShaper.process (x);

        // Pre-emphasis EQ (transformer coloration)
        shaped = lowBoost.process (shaped);
        shaped = highRoll.process (shaped);

        return shaped;
    }

    void reset()
    {
        lowBoost.reset();
        highRoll.reset();
        envLow.reset();
    }
};

//==============================================================================
// MODEL DEFINITIONS - Based on famous console characteristics
//==============================================================================
enum ModelId
{
    MODEL_CONSOLE_73 = 0,     // Neve 1073 style
    MODEL_BRITISH_CLEAN,      // SSL 4000 style
    MODEL_AMERICAN_PUNCH,     // API 512 style
    MODEL_DESK_CREAM,         // Trident A-Range style
    MODEL_CLASS_A_SILK,       // Harrison 32C style
    MODEL_ABBEY_GLOW,         // EMI TG12345 style
    MODEL_VALVE_WARMTH,       // Tube console style
    MODEL_TAPE_TOUCH,         // Studer/Ampex style
    MODEL_GERMANIUM_ERA,      // 60s germanium transistor
    MODEL_TRANSFORMER_IRON,   // Heavy transformer color
    MODEL_COUNT
};

//==============================================================================
// CONSOLE MODEL PARAMETERS
//==============================================================================
struct ConsoleModelParams
{
    // Harmonic content
    float h2;           // 2nd harmonic (even - warm)
    float h3;           // 3rd harmonic (odd - edge)
    float h4;           // 4th harmonic
    float h5;           // 5th harmonic
    float asymmetry;    // Asymmetric distortion amount

    // Drive and dynamics
    float baseDrive;    // Base drive amount
    float maxDrive;     // Maximum drive at 100%

    // Frequency response
    float hpFreq;       // Input highpass
    float lpFreq;       // Output lowpass
    float lowShelfFreq; // Low shelf frequency
    float lowShelfGain; // Low shelf gain (dB)
    float highShelfFreq;// High shelf frequency
    float highShelfGain;// High shelf gain (dB)

    // Multiband saturation balance
    float lowSatMult;   // Low band saturation multiplier
    float midSatMult;   // Mid band saturation multiplier
    float highSatMult;  // High band saturation multiplier

    // Crossover frequencies
    float crossLow;     // Low/mid crossover
    float crossHigh;    // Mid/high crossover

    // Dynamics
    float attackMs;     // Envelope attack
    float releaseMs;    // Envelope release
    float compression;  // Dynamic compression amount
};

static const ConsoleModelParams kModelParams[MODEL_COUNT] =
{
    // MODEL_CONSOLE_73 (Neve 1073 style)
    // Known for: Rich 3rd harmonic, transformer weight, musical saturation
    //         h2     h3     h4     h5     asym   bDrv   mDrv   hpF     lpF      lsF     lsG    hsF      hsG    lSat   mSat   hSat   xLo     xHi     atk    rel    comp
    {         0.15f, 0.35f, 0.08f, 0.12f, 0.1f,  1.0f,  3.5f,  20.0f,  18000.f, 100.0f, 1.5f,  8000.0f, -0.5f, 1.3f,  1.0f,  0.8f,  180.0f, 3500.f, 2.0f,  60.0f, 0.15f },

    // MODEL_BRITISH_CLEAN (SSL 4000 style)
    // Known for: Clean, punchy, controlled, tight low end
    {         0.05f, 0.12f, 0.03f, 0.02f, 0.0f,  1.0f,  2.2f,  25.0f,  20000.f, 80.0f,  0.3f,  12000.f, 0.5f,  0.8f,  1.0f,  1.1f,  150.0f, 4000.f, 0.5f,  40.0f, 0.08f },

    // MODEL_AMERICAN_PUNCH (API 512 style)
    // Known for: Punchy mids, 2nd+3rd balance, aggressive but musical
    {         0.22f, 0.28f, 0.10f, 0.08f, 0.05f, 1.0f,  4.0f,  30.0f,  16000.f, 120.0f, 1.0f,  6000.0f, 1.2f,  1.0f,  1.4f,  0.9f,  200.0f, 3000.f, 1.0f,  50.0f, 0.12f },

    // MODEL_DESK_CREAM (Trident A-Range style)
    // Known for: Creamy midrange, rich harmonics, vintage vibe
    {         0.25f, 0.20f, 0.12f, 0.06f, 0.08f, 1.0f,  3.2f,  25.0f,  15000.f, 150.0f, 1.8f,  5000.0f, -0.8f, 1.1f,  1.3f,  0.7f,  250.0f, 2800.f, 3.0f,  80.0f, 0.18f },

    // MODEL_CLASS_A_SILK (Harrison 32C style)
    // Known for: Clean warmth, silky highs, transparent coloration
    {         0.12f, 0.08f, 0.04f, 0.02f, 0.02f, 1.0f,  2.5f,  18.0f,  22000.f, 90.0f,  0.6f,  10000.f, 1.0f,  0.9f,  1.0f,  1.2f,  160.0f, 4500.f, 1.5f,  45.0f, 0.06f },

    // MODEL_ABBEY_GLOW (EMI TG12345 style)
    // Known for: Vintage colored, soft bandwidth, Beatles/Pink Floyd sound
    {         0.30f, 0.18f, 0.15f, 0.10f, 0.12f, 1.0f,  3.0f,  40.0f,  12000.f, 200.0f, 2.0f,  4000.0f, -1.5f, 1.2f,  1.1f,  0.6f,  220.0f, 2500.f, 4.0f,  100.f, 0.20f },

    // MODEL_VALVE_WARMTH (Tube console style)
    // Known for: 2nd harmonic dominant, soft compression, round tone
    {         0.40f, 0.12f, 0.08f, 0.03f, 0.15f, 1.0f,  3.8f,  22.0f,  14000.f, 100.0f, 1.2f,  6000.0f, -1.0f, 1.1f,  1.0f,  0.75f, 180.0f, 3200.f, 5.0f,  120.f, 0.25f },

    // MODEL_TAPE_TOUCH (Studer/Ampex style)
    // Known for: Head bump, HF saturation, gentle compression, hysteresis
    {         0.20f, 0.25f, 0.12f, 0.08f, 0.06f, 1.0f,  3.5f,  28.0f,  14000.f, 80.0f,  2.5f,  8000.0f, -2.0f, 1.0f,  1.0f,  1.3f,  150.0f, 4000.f, 1.0f,  70.0f, 0.22f },

    // MODEL_GERMANIUM_ERA (60s germanium transistor style)
    // Known for: Unpredictable, asymmetric, fuzzy, vintage character
    {         0.35f, 0.30f, 0.18f, 0.15f, 0.25f, 1.0f,  5.0f,  50.0f,  10000.f, 250.0f, 1.0f,  3500.0f, -2.5f, 1.2f,  1.4f,  0.5f,  300.0f, 2200.f, 2.0f,  90.0f, 0.18f },

    // MODEL_TRANSFORMER_IRON (Heavy transformer color)
    // Known for: Strong coloration, frequency-dependent saturation, weight
    {         0.18f, 0.42f, 0.14f, 0.18f, 0.08f, 1.0f,  4.5f,  25.0f,  16000.f, 80.0f,  2.2f,  5000.0f, -1.2f, 1.5f,  1.0f,  0.7f,  160.0f, 3000.f, 3.0f,  75.0f, 0.20f }
};

//==============================================================================
// CHANNEL PROCESSOR - Per-channel state for one console model
//==============================================================================
struct ChannelProcessor
{
    // Input stage
    OnePoleHP inputHP;
    DcBlocker dcIn;

    // Multiband
    ThreeBandCrossover crossover;
    HarmonicShaper lowShaper, midShaper, highShaper;

    // EQ
    Biquad lowShelf;
    Biquad highShelf;

    // Output stage
    OnePoleLP outputLP;
    DcBlocker dcOut;

    // Dynamics
    EnvelopeFollower envelope;

    // State
    float sr = 44100.0f;
    int currentModel = -1;

    void prepare (float sampleRate)
    {
        sr = sampleRate;
        currentModel = -1;  // Force reconfiguration

        dcIn.setFreq (8.0f, sr);
        dcOut.setFreq (5.0f, sr);

        reset();
    }

    void reset()
    {
        inputHP.reset();
        dcIn.reset();
        crossover.reset();
        lowShelf.reset();
        highShelf.reset();
        outputLP.reset();
        dcOut.reset();
        envelope.reset();
    }

    void configureForModel (int model, float amount)
    {
        if (model < 0 || model >= MODEL_COUNT)
            model = 0;

        const auto& p = kModelParams[model];

        // Input HP
        inputHP.setCutoff (lerpf (10.0f, p.hpFreq, amount), sr);

        // Crossover
        crossover.setup (p.crossLow, p.crossHigh, sr);

        // Calculate drive based on amount
        float drive = lerpf (p.baseDrive, p.maxDrive, amount);

        // Configure band shapers with model's harmonic profile
        auto configShaper = [&] (HarmonicShaper& shaper, float mult)
        {
            shaper.h2 = p.h2 * amount;
            shaper.h3 = p.h3 * amount;
            shaper.h4 = p.h4 * amount;
            shaper.h5 = p.h5 * amount;
            shaper.drive = drive * mult;
            shaper.asymmetry = p.asymmetry * amount;
        };

        configShaper (lowShaper, p.lowSatMult);
        configShaper (midShaper, p.midSatMult);
        configShaper (highShaper, p.highSatMult);

        // EQ - scaled by amount
        float lowGain = p.lowShelfGain * amount;
        float highGain = p.highShelfGain * amount;
        lowShelf.setLowShelf (p.lowShelfFreq, lowGain, sr);
        highShelf.setHighShelf (p.highShelfFreq, highGain, sr);

        // Output LP
        float lpFreq = lerpf (20000.0f, p.lpFreq, amount);
        outputLP.setCutoff (lpFreq, sr);

        // Dynamics
        envelope.setTimes (p.attackMs, p.releaseMs, sr);

        currentModel = model;
    }

    float process (float x, int model, float amount)
    {
        // Reconfigure if model changed (or periodically for amount changes)
        if (model != currentModel)
            configureForModel (model, amount);

        const auto& p = kModelParams[model];

        // Input DC block and HP
        x = dcIn.process (x);
        x = inputHP.process (x);

        // Envelope for dynamics
        float env = envelope.process (x);

        // Dynamic drive modulation (compression behavior)
        float compression = p.compression * amount;
        float dynamicGain = 1.0f - compression * clampf (env * 2.0f, 0.0f, 1.0f);

        // Split into bands
        float low, mid, high;
        crossover.process (x, low, mid, high);

        // Apply saturation to each band
        float drive = lerpf (p.baseDrive, p.maxDrive, amount);

        // Update shapers with dynamic drive
        lowShaper.drive = drive * p.lowSatMult * dynamicGain;
        midShaper.drive = drive * p.midSatMult;
        highShaper.drive = drive * p.highSatMult * (1.0f + compression * 0.3f);

        low = lowShaper.process (low);
        mid = midShaper.process (mid);
        high = highShaper.process (high);

        // Recombine
        float y = low + mid + high;

        // Apply EQ coloration
        y = lowShelf.process (y);
        y = highShelf.process (y);

        // Output LP and DC block
        y = outputLP.process (y);
        y = dcOut.process (y);

        // Soft limit to prevent overs
        y = fastTanh (y * 0.9f) / 0.9f;

        return y;
    }
};

//==============================================================================
// MAIN DSP ENGINE
//==============================================================================
class VillainAudioProcessor::AnalogEngine
{
public:
    void prepare (double sampleRate)
    {
        sr = sampleRate > 1000.0 ? sampleRate : 44100.0;
        left.prepare ((float) sr);
        right.prepare ((float) sr);
    }

    void process (juce::AudioBuffer<float>& buffer, int model, float mix01)
    {
        const int numChannels = buffer.getNumChannels();
        const int numSamples = buffer.getNumSamples();
        const float wetMix = clampf (mix01, 0.0f, 1.0f);

        // Early exit if mix is zero
        if (wetMix < 0.0001f)
            return;

        const float dryMix = 1.0f - wetMix;

        auto* ch0 = buffer.getWritePointer (0);
        auto* ch1 = numChannels > 1 ? buffer.getWritePointer (1) : nullptr;

        // Configure processors for current model and amount
        // Note: amount is the wet mix - more mix = more effect intensity
        left.configureForModel (model, wetMix);
        right.configureForModel (model, wetMix);

        for (int i = 0; i < numSamples; ++i)
        {
            const float inL = ch0[i];
            const float inR = ch1 ? ch1[i] : inL;

            // Process through console model
            const float wetL = left.process (inL, model, wetMix);
            const float wetR = right.process (inR, model, wetMix);

            // Dry/wet mix
            ch0[i] = dryMix * inL + wetMix * wetL;
            if (ch1)
                ch1[i] = dryMix * inR + wetMix * wetR;
        }
    }

private:
    double sr = 44100.0;
    ChannelProcessor left;
    ChannelProcessor right;
};

//==============================================================================
// PLUGIN PROCESSOR IMPLEMENTATION
//==============================================================================
VillainAudioProcessor::VillainAudioProcessor()
    : AudioProcessor (BusesProperties()
        .withInput  ("Input",  juce::AudioChannelSet::stereo(), true)
        .withOutput ("Output", juce::AudioChannelSet::stereo(), true)),
      apvts (*this, nullptr, "PARAMS", createParameterLayout())
{
    engine = std::make_unique<AnalogEngine>();
}

VillainAudioProcessor::~VillainAudioProcessor() = default;

//==============================================================================
juce::AudioProcessorValueTreeState::ParameterLayout VillainAudioProcessor::createParameterLayout()
{
    std::vector<std::unique_ptr<juce::RangedAudioParameter>> params;

    params.push_back (std::make_unique<juce::AudioParameterInt>(
        juce::ParameterID { paramModelId, 1 }, "Model", 0, kNumModels - 1, 0));

    params.push_back (std::make_unique<juce::AudioParameterFloat>(
        juce::ParameterID { paramMixId, 1 }, "Mix", juce::NormalisableRange<float> (0.0f, 1.0f, 0.0001f), 0.0f));

    return { params.begin(), params.end() };
}

juce::StringArray VillainAudioProcessor::getModelNames()
{
    return {
        "1. 73",
        "2. British Clean",
        "3. American Punch",
        "4. Chocolate Cream",
        "5. Silk Milk",
        "6. Low Glow",
        "7. Valve Storm",
        "8. Stereo Tape",
        "9. Germanium",
        "10. Iron Moon"
    };
}

const juce::String VillainAudioProcessor::getName() const { return JucePlugin_Name; }
bool VillainAudioProcessor::acceptsMidi() const { return false; }
bool VillainAudioProcessor::producesMidi() const { return false; }
bool VillainAudioProcessor::isMidiEffect() const { return false; }
double VillainAudioProcessor::getTailLengthSeconds() const { return 0.0; }

int VillainAudioProcessor::getNumPrograms() { return 1; }
int VillainAudioProcessor::getCurrentProgram() { return 0; }
void VillainAudioProcessor::setCurrentProgram (int) {}
const juce::String VillainAudioProcessor::getProgramName (int) { return {}; }
void VillainAudioProcessor::changeProgramName (int, const juce::String&) {}

//==============================================================================
void VillainAudioProcessor::prepareToPlay (double sampleRate, int)
{
    if (engine)
        engine->prepare (sampleRate);
}

void VillainAudioProcessor::releaseResources() {}

#ifndef JucePlugin_PreferredChannelConfigurations
bool VillainAudioProcessor::isBusesLayoutSupported (const BusesLayout& layouts) const
{
    const auto& in  = layouts.getMainInputChannelSet();
    const auto& out = layouts.getMainOutputChannelSet();
    return (in == out) && (in == juce::AudioChannelSet::mono() || in == juce::AudioChannelSet::stereo());
}
#endif

void VillainAudioProcessor::processBlock (juce::AudioBuffer<float>& buffer, juce::MidiBuffer&)
{
    juce::ScopedNoDenormals noDenormals;

    for (int ch = getTotalNumInputChannels(); ch < getTotalNumOutputChannels(); ++ch)
        buffer.clear (ch, 0, buffer.getNumSamples());

    const int model = clampi ((int) apvts.getRawParameterValue (paramModelId)->load(), 0, kNumModels - 1);
    const float mix = clampf (apvts.getRawParameterValue (paramMixId)->load(), 0.0f, 1.0f);

    if (engine)
        engine->process (buffer, model, mix);
}

//==============================================================================
bool VillainAudioProcessor::hasEditor() const { return true; }

juce::AudioProcessorEditor* VillainAudioProcessor::createEditor()
{
    return new VillainAudioProcessorEditor (*this);
}

//==============================================================================
void VillainAudioProcessor::setCurrentPresetName (const juce::String& name)
{
    currentPresetName = name.isNotEmpty() ? name : "Default";
}

juce::String VillainAudioProcessor::getCurrentPresetName() const
{
    return currentPresetName.isNotEmpty() ? currentPresetName : "Default";
}

static juce::ValueTree makeStateForSave (juce::AudioProcessorValueTreeState& apvts, const juce::String& presetName)
{
    juce::ValueTree root ("VILLAIN_STATE");
    root.setProperty ("presetName", presetName, nullptr);
    root.addChild (apvts.copyState(), -1, nullptr);
    return root;
}

void VillainAudioProcessor::getStateInformation (juce::MemoryBlock& destData)
{
    auto root = makeStateForSave (apvts, getCurrentPresetName());
    std::unique_ptr<juce::XmlElement> xml (root.createXml());
    copyXmlToBinary (*xml, destData);
}

void VillainAudioProcessor::setStateInformation (const void* data, int sizeInBytes)
{
    std::unique_ptr<juce::XmlElement> xml (getXmlFromBinary (data, sizeInBytes));
    if (!xml)
        return;

    auto root = juce::ValueTree::fromXml (*xml);

    if (root.hasType ("VILLAIN_STATE"))
    {
        const auto pn = root.getProperty ("presetName").toString();
        setCurrentPresetName (pn);

        auto child = root.getChild (0);
        if (child.isValid())
            apvts.replaceState (child);
    }
    else
    {
        auto vt = juce::ValueTree::fromXml (*xml);
        if (vt.isValid())
            apvts.replaceState (vt);
    }
}

bool VillainAudioProcessor::savePresetToFile (const juce::File& file, const juce::String& presetName, juce::String& errorOut)
{
    errorOut.clear();

    if (file == juce::File() || file.getFullPathName().isEmpty())
    {
        errorOut = "Invalid file.";
        return false;
    }

    auto root = makeStateForSave (apvts, presetName);
    std::unique_ptr<juce::XmlElement> xml (root.createXml());
    if (!xml)
    {
        errorOut = "Failed to create XML.";
        return false;
    }

    if (!xml->writeTo (file, {}))
    {
        errorOut = "Failed to write preset file.";
        return false;
    }

    setCurrentPresetName (presetName);
    return true;
}

bool VillainAudioProcessor::loadPresetFromFile (const juce::File& file, juce::String& loadedPresetName, juce::String& errorOut)
{
    errorOut.clear();
    loadedPresetName.clear();

    if (!file.existsAsFile())
    {
        errorOut = "Preset file not found.";
        return false;
    }

    std::unique_ptr<juce::XmlElement> xml (juce::XmlDocument::parse (file));
    if (!xml)
    {
        errorOut = "Invalid preset file (XML parse failed).";
        return false;
    }

    auto root = juce::ValueTree::fromXml (*xml);
    if (!root.isValid())
    {
        errorOut = "Invalid preset file (no state).";
        return false;
    }

    if (root.hasType ("VILLAIN_STATE"))
    {
        loadedPresetName = root.getProperty ("presetName").toString();
        if (loadedPresetName.isEmpty())
            loadedPresetName = file.getFileNameWithoutExtension();

        setCurrentPresetName (loadedPresetName);

        auto child = root.getChild (0);
        if (child.isValid())
            apvts.replaceState (child);
        else
            errorOut = "Preset missing parameter state.";
    }
    else
    {
        apvts.replaceState (root);
        loadedPresetName = file.getFileNameWithoutExtension();
        setCurrentPresetName (loadedPresetName);
    }

    return errorOut.isEmpty();
}

//==============================================================================
juce::AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new VillainAudioProcessor();
}




--------------------------------------------------------------------------------
File: src/PluginProcessor.h
Size: 3.02 KB
--------------------------------------------------------------------------------

#pragma once

// JUCE CMake projects do NOT generate JuceHeader.h.
#include <juce_audio_processors/juce_audio_processors.h>
#include <juce_dsp/juce_dsp.h>
#include <juce_audio_utils/juce_audio_utils.h>
#include <juce_gui_basics/juce_gui_basics.h>

class VillainAudioProcessor final : public juce::AudioProcessor
{
public:
    VillainAudioProcessor();
    ~VillainAudioProcessor() override;

    //==============================================================================
    void prepareToPlay (double sampleRate, int samplesPerBlock) override;
    void releaseResources() override;

   #ifndef JucePlugin_PreferredChannelConfigurations
    bool isBusesLayoutSupported (const BusesLayout& layouts) const override;
   #endif

    void processBlock (juce::AudioBuffer<float>&, juce::MidiBuffer&) override;

    //==============================================================================
    juce::AudioProcessorEditor* createEditor() override;
    bool hasEditor() const override;

    //==============================================================================
    const juce::String getName() const override;

    bool acceptsMidi() const override;
    bool producesMidi() const override;
    bool isMidiEffect() const override;
    double getTailLengthSeconds() const override;

    //==============================================================================
    int getNumPrograms() override;
    int getCurrentProgram() override;
    void setCurrentProgram (int index) override;
    const juce::String getProgramName (int index) override;
    void changeProgramName (int index, const juce::String& newName) override;

    //==============================================================================
    void getStateInformation (juce::MemoryBlock& destData) override;
    void setStateInformation (const void* data, int sizeInBytes) override;

    //==============================================================================
    juce::AudioProcessorValueTreeState& getAPVTS() { return apvts; }

    static constexpr const char* paramModelId = "model";
    static constexpr const char* paramMixId   = "mix";

    static constexpr int kNumModels = 10;

    static juce::AudioProcessorValueTreeState::ParameterLayout createParameterLayout();
    static juce::StringArray getModelNames();

    // Preset helpers (file-based preset format via APVTS XML)
    bool savePresetToFile (const juce::File& file, const juce::String& presetName, juce::String& errorOut);
    bool loadPresetFromFile (const juce::File& file, juce::String& loadedPresetName, juce::String& errorOut);

    void setCurrentPresetName (const juce::String& name);
    juce::String getCurrentPresetName() const;

private:
    juce::AudioProcessorValueTreeState apvts;

    // persisted in DAW state (so the preset name shows correctly after reload)
    juce::String currentPresetName { "Default" };

    // Forward-declared DSP engine (defined in .cpp)
    class AnalogEngine;
    std::unique_ptr<AnalogEngine> engine;

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR (VillainAudioProcessor)
};




--------------------------------------------------------------------------------
File: CMakeLists.txt
Size: 4.13 KB
--------------------------------------------------------------------------------

cmake_minimum_required(VERSION 3.22)

project(Villain VERSION 1.0.0 LANGUAGES C CXX)

set(CMAKE_CXX_STANDARD 17)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# ==============================================================================
# Build options
# ==============================================================================
option(VILLAIN_ENABLE_VST3   "Enable VST3 format" OFF)
option(VILLAIN_ENABLE_AU     "Enable AU format (macOS only)" ON)
option(VILLAIN_ENABLE_CLAP   "Enable CLAP format" OFF)

# JUCE location
set(JUCE_DIR "${CMAKE_CURRENT_SOURCE_DIR}/libs/JUCE" CACHE PATH "Path to JUCE")

# CLAP extensions location
set(CLAP_EXTENSIONS_DIR "" CACHE PATH "Path to clap-juce-extensions root folder")

# ==============================================================================
# JUCE
# ==============================================================================
add_subdirectory("${JUCE_DIR}" "${CMAKE_BINARY_DIR}/JUCE")

# ==============================================================================
# Sources
# ==============================================================================
set(VILLAIN_SRC
    src/PluginProcessor.h
    src/PluginProcessor.cpp
    src/PluginEditor.h
    src/PluginEditor.cpp
)

# ==============================================================================
# Assets
# ==============================================================================
juce_add_binary_data(VillainAssets SOURCES
    assets/a1.png
    assets/a2.png
    assets/a3.png
    assets/a4.png
    assets/a5.png
    assets/a6.png
    assets/a7.png
    assets/a8.png
    assets/a9.png
    assets/a10.png
    assets/knob.png
)

# ==============================================================================
# Build formats list
# ==============================================================================
set(_formats "")

if(VILLAIN_ENABLE_VST3)
    list(APPEND _formats VST3)
endif()

if(APPLE AND VILLAIN_ENABLE_AU)
    list(APPEND _formats AU)
endif()

# CLAP requires VST3 as base format
if(VILLAIN_ENABLE_CLAP AND NOT "${CLAP_EXTENSIONS_DIR}" STREQUAL "")
    if(NOT TARGET clap_juce_extensions)
        add_subdirectory("${CLAP_EXTENSIONS_DIR}" "${CMAKE_BINARY_DIR}/clap_juce_extensions_build")
    endif()
    # Ensure VST3 is in formats for CLAP to work
    if(NOT "VST3" IN_LIST _formats)
        list(APPEND _formats VST3)
    endif()
endif()

if(NOT _formats)
    message(FATAL_ERROR "No plugin formats enabled!")
endif()

message(STATUS "Building Villain with formats: ${_formats}")

# ==============================================================================
# Villain Plugin
# ==============================================================================
juce_add_plugin(Villain
    COMPANY_NAME "Fanan"
    COMPANY_COPYRIGHT "Copyright (c) Fanan"
    PRODUCT_NAME "Villain"
    PLUGIN_MANUFACTURER_CODE FANa
    PLUGIN_CODE VLAN
    FORMATS ${_formats}
    IS_SYNTH FALSE
    NEEDS_MIDI_INPUT FALSE
    NEEDS_MIDI_OUTPUT FALSE
    IS_MIDI_EFFECT FALSE
    MICROPHONE_PERMISSION_ENABLED FALSE
    CAMERA_PERMISSION_ENABLED FALSE
    COPY_PLUGIN_AFTER_BUILD TRUE
)

target_sources(Villain PRIVATE ${VILLAIN_SRC})

target_compile_features(Villain PRIVATE cxx_std_17)

target_compile_definitions(Villain
    PRIVATE
        JUCE_WEB_BROWSER=0
        JUCE_USE_CURL=0
        JUCE_VST3_CAN_REPLACE_VST2=0
)

target_link_libraries(Villain
    PRIVATE
        VillainAssets
        juce::juce_audio_utils
        juce::juce_audio_processors
        juce::juce_dsp
        juce::juce_gui_extra
    PUBLIC
        juce::juce_recommended_config_flags
        juce::juce_recommended_warning_flags
        juce::juce_recommended_lto_flags
)

# ==============================================================================
# CLAP support (when enabled)
# ==============================================================================
if(VILLAIN_ENABLE_CLAP AND TARGET clap_juce_extensions)
    clap_juce_extensions_plugin(
        TARGET Villain
        CLAP_ID "com.fanan.villain"
        CLAP_FEATURES "audio-effect" "stereo"
        CLAP_MANUAL_URL "https://fanan.com/villain"
        CLAP_SUPPORT_URL "https://fanan.com/support"
        CLAP_USE_JUCE_PARAMETER_RANGES ALL
    )
endif()



================================================================================
End of Documentation
Generated by Code PDF Builder on January 24, 2026
================================================================================
